# Аналіз продуктивності

## Методологія

Для профілювання продуктивності Java-додатку з використанням JavaFX буd використаний інструмент:

- **JProfiler** — потужний комерційний інструмент з глибоким аналізом CPU, памʼяті та SQL-запитів.

Було налаштовано плагіни в IntelliJ IDEA для інтеграції з вищезазначеними інструментами. У тестовому сценарії виконувалися базові дії користувача, зокрема: додавання/видалення продуктів у кошик, перегляд вмісту кошика та завершення касової операції.

## Ключові метрики

### 1. CPU-профілювання

**Топ-3 «гарячі точки»:**

| Метод                                   | Час виконання | Частка навантаження | Коментар |
|----------------------------------------|----------------|---------------------|----------|
| `javafx.stage.Stage.show`              | 562 ms         | 28%                 | Повільне створення/рендеринг GUI |
| `java.net.http.HttpClient.newHttpClient` | 318 ms         | 16%                 | Варто повторно використовувати HTTP-клієнт |
| `java.net.http.HttpClient.send`        | 298 ms         | 15%                 | Потрібна оптимізація HTTP-запитів |

### 2. Профілювання запитів до БД (JDBC)

| SQL-запит                                        | Час виконання | Частка навантаження | Коментар |
|--------------------------------------------------|----------------|---------------------|----------|
| `UPDATE catalog SET num = ? WHERE name = ?`     | 30,529 µs      | 47%                 | Потрібен індекс по `name` |
| `UPDATE catalog SET num = 0`                    | 15,206 µs      | 23%                 | Варто виділити окрему таблицю для кошика |
| `UPDATE catalog SET num = 0 WHERE name = ?`     | 14,728 µs      | 23%                 | Також рекомендований індекс по `name` |

### 3. Профілювання памʼяті

- Власні класи не потрапили в топ-споживачі памʼяті.
- Ознак витоків памʼяті не виявлено.
- Оптимізація памʼяті наразі не є пріоритетною.

## Виявлені проблеми з продуктивністю

1. **Ініціалізація GUI** — занадто тривала. Можливо, варто відкласти завантаження деяких сцен або використовувати lazy loading.
2. **Створення HTTP-клієнта** — створюється при кожному запиті. Оптимізація: реалізувати пул або singleton.
3. **Повільні SQL-запити** — особливо при оновленні `catalog`. Оптимізація: додати індекси по полю `name`, розглянути нормалізацію таблиць (наприклад, окрема таблиця для кошика).

---

Хочете, я одразу згенерую цей файл у форматі `.md` і підготую для завантаження?
